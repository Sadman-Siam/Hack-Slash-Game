import random
import math
import time

active_enemies = []
bosses = []
MAX_ENEMIES = 5

MELEE_CREATURE = 1
RANGED_ATTACKER = 2
FINAL_BOSS = 3

class EnemyCreature:
    def __init__(self, x_coord, y_coord, z_coord, creature_type):
        self.x, self.y, self.z = x_coord, y_coord, z_coord
        self.creature_type = creature_type
        self.current_health = 500 if creature_type == FINAL_BOSS else 100
        self.maximum_health = self.current_health
        self.movement_speed = 1.0 if creature_type == FINAL_BOSS else (2.0 if creature_type == MELEE_CREATURE else 1.5)
        self.is_dead = False
        self.animation_time = 0
        self.initial_x, self.initial_y = x_coord, y_coord
        self.behavior_state = "wandering"
        self.collision_radius = 80 if creature_type == FINAL_BOSS else 40
        
        self.equipped_weapon = "sword"
        self.sword_range = 100 if creature_type == FINAL_BOSS else 80
        self.gun_range = 400 if creature_type == FINAL_BOSS else 300
        self.sword_damage = 60 if creature_type == FINAL_BOSS else 30
        self.gun_damage = 40 if creature_type == FINAL_BOSS else 20
        self.sword_cooldown = 0.5 if creature_type == FINAL_BOSS else 0.8
        self.gun_cooldown = 1.0 if creature_type == FINAL_BOSS else 1.5
        self.last_attack_time = 0
        self.is_swinging = False
        self.swing_duration_timer = 0
        
        if creature_type == FINAL_BOSS:
            self.special_attack_cooldown = 5.0
            self.last_special_attack_time = 0
        
        self.projectiles = []
        self.patrol_direction = random.random() * 6.28
        self.wander_distance = 100
        self.target_position = [0, 0, 50]

    def update(self, delta_time):
        if self.is_dead:
            return
            
        self.animation_time += delta_time
        current_time = time.time()
        
        self.patrol_direction += delta_time * 0.5
        
        self.target_position[0] = player_x
        self.target_position[1] = player_y
        self.target_position[2] = player_z
        
        distance_to_player = self.get_distance(self.target_position)
        
        if distance_to_player <= self.sword_range:
            self.equipped_weapon = "sword"
        elif distance_to_player <= self.gun_range:
            self.equipped_weapon = "gun"
        else:
            self.equipped_weapon = "gun"
        
        if self.is_swinging:
            self.swing_duration_timer += delta_time
            if self.swing_duration_timer > 0.5:
                self.is_swinging = False
                self.swing_duration_timer = 0
        
        self.handle_ai_behavior(delta_time, distance_to_player, current_time)
        self.update_projectiles(delta_time)

    def get_distance(self, target):
        dx = self.x - target[0]
        dy = self.y - target[1]
        return math.sqrt(dx*dx + dy*dy)

    def handle_ai_behavior(self, delta_time, distance_to_player, current_time):
        if self.creature_type == MELEE_CREATURE:
            if distance_to_player < 350:
                self.behavior_state = "hunting"
                if distance_to_player > self.sword_range and self.equipped_weapon == "sword":
                    dx = self.target_position[0] - self.x
                    dy = self.target_position[1] - self.y
                    length = math.sqrt(dx*dx + dy*dy)
                    if length > 0:
                        self.x += (dx/length) * self.movement_speed * delta_time * 60
                        self.y += (dy/length) * self.movement_speed * delta_time * 60
                else:
                    self.behavior_state = "fighting"
                    delay = self.sword_cooldown if self.equipped_weapon == "sword" else self.gun_cooldown
                    if current_time - self.last_attack_time > delay:
                        self.execute_attack()
                        self.last_attack_time = current_time
            else:
                self.behavior_state = "wandering"
                self.wander_around(delta_time)
        
        elif self.creature_type == RANGED_ATTACKER:
            if distance_to_player < 400:
                if distance_to_player <= self.sword_range and self.equipped_weapon == "sword":
                    self.behavior_state = "fighting"
                    if current_time - self.last_attack_time > self.sword_cooldown:
                        self.perform_sword_swing()
                        self.last_attack_time = current_time
                elif distance_to_player <= self.gun_range and self.equipped_weapon == "gun":
                    self.behavior_state = "fighting"
                    if current_time - self.last_attack_time > self.gun_cooldown:
                        self.fire_gun()
                        self.last_attack_time = current_time
                else:
                    self.behavior_state = "positioning"
                    optimal_range = self.gun_range * 0.7
                    if distance_to_player < optimal_range:
                        dx = self.x - self.target_position[0]
                        dy = self.y - self.target_position[1]
                        length = math.sqrt(dx*dx + dy*dy)
                        if length > 0:
                            self.x += (dx/length) * self.movement_speed * delta_time * 40
                            self.y += (dy/length) * self.movement_speed * delta_time * 40
                    else:
                        dx = self.target_position[0] - self.x
                        dy = self.target_position[1] - self.y
                        length = math.sqrt(dx*dx + dy*dy)
                        if length > 0:
                            self.x += (dx/length) * self.movement_speed * delta_time * 40
                            self.y += (dy/length) * self.movement_speed * delta_time * 40
            else:
                self.behavior_state = "wandering"
                self.wander_around(delta_time)
        
        elif self.creature_type == FINAL_BOSS:
            if distance_to_player < 500:
                if distance_to_player > self.sword_range:
                    self.behavior_state = "hunting"
                    dx = self.target_position[0] - self.x
                    dy = self.target_position[1] - self.y
                    length = math.sqrt(dx*dx + dy*dy)
                    if length > 0:
                        self.x += (dx/length) * self.movement_speed * delta_time * 60
                        self.y += (dy/length) * self.movement_speed * delta_time * 60
                
                self.behavior_state = "fighting"
                delay = self.sword_cooldown if self.equipped_weapon == "sword" else self.gun_cooldown
                if current_time - self.last_attack_time > delay:
                    if self.equipped_weapon == "sword":
                        self.perform_sword_swing()
                    else:
                        self.fire_gun()
                    self.last_attack_time = current_time
                
                if current_time - self.last_special_attack_time > self.special_attack_cooldown:
                    self.execute_boss_special_attack()
                    self.last_special_attack_time = current_time

    def wander_around(self, delta_time):
        angle = self.patrol_direction
        target_x = self.initial_x + math.cos(angle) * self.wander_distance
        target_y = self.initial_y + math.sin(angle) * self.wander_distance
        
        dx = target_x - self.x
        dy = target_y - self.y
        length = math.sqrt(dx*dx + dy*dy)
        if length > 5:
            self.x += (dx/length) * self.movement_speed * delta_time * 30
            self.y += (dy/length) * self.movement_speed * delta_time * 30

    def execute_attack(self):
        if self.equipped_weapon == "sword":
            self.perform_sword_swing()
        else:
            self.fire_gun()

    def perform_sword_swing(self):
        self.is_swinging = True
        self.swing_duration_timer = 0

    def fire_gun(self):
        dx = self.target_position[0] - self.x
        dy = self.target_position[1] - self.y
        length = math.sqrt(dx*dx + dy*dy)
        if length > 0:
            velocity_x = dx/length * 250
            velocity_y = dy/length * 250
            projectile = {
                'x': self.x, 'y': self.y, 'z': self.z + 20,
                'vx': velocity_x, 'vy': velocity_y,
                'lifetime': 4.0, 'damage': self.gun_damage,
                'is_special': False
            }
            self.projectiles.append(projectile)

    def execute_boss_special_attack(self):
        if self.creature_type == FINAL_BOSS:
            self.is_swinging = True
            for i in range(0, 360, 20):
                angle = math.radians(i)
                velocity_x = math.cos(angle) * 200
                velocity_y = math.sin(angle) * 200
                projectile = {
                    'x': self.x, 'y': self.y, 'z': self.z + 20,
                    'vx': velocity_x, 'vy': velocity_y,
                    'lifetime': 5.0, 'damage': self.gun_damage,
                    'is_special': True
                }
                self.projectiles.append(projectile)

    def update_projectiles(self, delta_time):
        for projectile in self.projectiles[:]:
            projectile['x'] += projectile['vx'] * delta_time
            projectile['y'] += projectile['vy'] * delta_time
            projectile['lifetime'] -= delta_time
            
            if projectile['lifetime'] <= 0:
                self.projectiles.remove(projectile)

    def take_damage(self, damage_amount):
        self.current_health -= damage_amount
        if self.current_health <= 0:
            self.is_dead = True

    def render_creature(self):
        if self.is_dead:
            return

        current_time = glutGet(GLUT_ELAPSED_TIME) / 500.0
        scale_effect = 1.0 + 0.3 * math.sin(2 * math.pi * current_time)

        glPushMatrix()
        glTranslatef(self.x, self.y, self.z)
        
        glScalef(scale_effect, scale_effect, scale_effect)
        
        if self.creature_type == MELEE_CREATURE:
            glPushMatrix()
            glColor3f(1, 0, 0)
            glutSolidSphere(25, 20, 20)
            glPopMatrix()
            
            glPushMatrix()
            glColor3f(0, 0, 0)
            glTranslatef(0, 0, 30)
            glutSolidSphere(12, 16, 16)
            glPopMatrix()
            
        elif self.creature_type == RANGED_ATTACKER:
            glPushMatrix()
            glColor3f(1, 0, 0)
            glutSolidSphere(25, 20, 20)
            glPopMatrix()
            
            glPushMatrix()
            glColor3f(0, 0, 0)
            glTranslatef(0, 0, 30)
            glutSolidSphere(12, 16, 16)
            glPopMatrix()
            
        else:
            glPushMatrix()
            glColor3f(1, 0, 0)
            glutSolidSphere(35, 20, 20)
            glPopMatrix()
            
            glPushMatrix()
            glColor3f(0, 0, 0)
            glTranslatef(0, 0, 40)
            glutSolidSphere(18, 16, 16)
            glPopMatrix()
        
        self.draw_current_weapon()
        glPopMatrix()
        
        self.draw_health_bar()
        self.draw_projectiles()

    def draw_current_weapon(self):
        if self.equipped_weapon == "sword":
            self.draw_sword()
        else:
            self.draw_gun()
    
    def draw_sword(self):
        glPushMatrix()
        glTranslatef(self.collision_radius * 0.7, 0, 0)
        
        if self.is_swinging:
            swing = math.sin(self.swing_duration_timer * 10) * 50
            glRotatef(swing, 0, 0, 1)
        
        if self.creature_type == MELEE_CREATURE:
            glColor3f(0.9, 0.0, 0.0)
            glPushMatrix()
            glScalef(0.08, 0.9, 0.04)
            glutSolidCube(80)
            glPopMatrix()
            
            glColor3f(1.0, 0.3, 0.3)
            for i in range(5):
                glPushMatrix()
                glTranslatef(random.randint(-3, 3), i * 12 - 30, random.randint(-2, 2))
                glutSolidSphere(2, 6, 6)
                glPopMatrix()
                
        elif self.creature_type == FINAL_BOSS:
            glColor3f(0.6, 0.5, 0.2)
            glPushMatrix()
            glScalef(0.12, 1.1, 0.06)
            glutSolidCube(90)
            glPopMatrix()
            
            glColor3f(1.0, 0.8, 0.0)
            for i in range(4):
                glPushMatrix()
                glTranslatef(0, i * 15 - 30, 0)
                glutSolidCube(6)
                glPopMatrix()
        else:
            glColor3f(0.0, 0.8, 1.0)
            glPushMatrix()
            glScalef(0.05, 0.8, 0.03)
            glutSolidCube(70)
            glPopMatrix()
        
        glColor3f(0.15, 0.15, 0.2)
        glPushMatrix()
        glTranslatef(0, -40, 0)
        glutSolidCylinder(6, 25, 8, 8)
        glPopMatrix()
        
        glPopMatrix()
    
    def draw_gun(self):
        glPushMatrix()
        glTranslatef(self.collision_radius * 0.6, 0, 10)
        
        dx = self.target_position[0] - self.x
        dy = self.target_position[1] - self.y
        if dx != 0 or dy != 0:
            angle = math.degrees(math.atan2(dy, dx))
            glRotatef(angle, 0, 0, 1)
        
        if self.creature_type == RANGED_ATTACKER:
            glColor3f(0.1, 0.15, 0.2)
            glPushMatrix()
            glTranslatef(25, 0, 0)
            glRotatef(90, 0, 1, 0)
            glutSolidCylinder(6, 50, 8, 8)
            glPopMatrix()
            
            glColor3f(0.0, 0.6, 1.0)
            glPushMatrix()
            glTranslatef(10, 0, 0)
            glutSolidSphere(8, 10, 10)
            glPopMatrix()
            
        elif self.creature_type == FINAL_BOSS:
            glColor3f(0.3, 0.25, 0.15)
            glPushMatrix()
            glTranslatef(35, 0, 0)
            glRotatef(90, 0, 1, 0)
            glutSolidCylinder(10, 80, 12, 12)
            glPopMatrix()
            
            glColor3f(0.8, 0.6, 0.2)
            glPushMatrix()
            glTranslatef(60, 0, 0)
            glutSolidSphere(18, 12, 12)
            glPopMatrix()
            
        else:
            glColor3f(0.3, 0.3, 0.35)
            glPushMatrix()
            glTranslatef(20, 0, 0)
            glScalef(0.7, 0.12, 0.12)
            glutSolidCube(35)
            glPopMatrix()
        
        glPopMatrix()

    def draw_health_bar(self):
        if self.is_dead:
            return
            
        glPushMatrix()
        glTranslatef(self.x, self.y, self.z + self.collision_radius + 30)
        
        glRotatef(90 - math.degrees(math.atan2(player_y - self.y, player_x - self.x)), 0, 0, 1)
        
        glColor3f(0.2, 0.2, 0.2)
        glBegin(GL_QUADS)
        glVertex3f(-25, -3, 0)
        glVertex3f(25, -3, 0)
        glVertex3f(25, 3, 0)
        glVertex3f(-25, 3, 0)
        glEnd()
        
        health_percentage = self.current_health / self.maximum_health
        if health_percentage > 0.6:
            glColor3f(0.0, 1.0, 0.0)
        elif health_percentage > 0.3:
            glColor3f(1.0, 1.0, 0.0)
        else:
            glColor3f(1.0, 0.0, 0.0)
            
        glBegin(GL_QUADS)
        glVertex3f(-25, -2, 1)
        glVertex3f(-25 + 50 * health_percentage, -2, 1)
        glVertex3f(-25 + 50 * health_percentage, 2, 1)
        glVertex3f(-25, 2, 1)
        glEnd()
        
        glPopMatrix()

    def draw_projectiles(self):
        for projectile in self.projectiles:
            glPushMatrix()
            glTranslatef(projectile['x'], projectile['y'], projectile['z'])
            
            if projectile['is_special']:
                glRotatef(time.time() * 120, 0, 1, 0)
                glColor3f(1.0, 0.8, 0.3)
                glutSolidCube(16)
                glColor3f(0.8, 0.6, 0.2)
                glutWireCube(20)
            elif self.creature_type == RANGED_ATTACKER:
                glColor3f(0.2, 0.8, 1.0)
                glutSolidSphere(8, 10, 10)
                glColor3f(0.0, 0.4, 0.8)
                for i in range(3):
                    glPushMatrix()
                    glTranslatef(-i * 6, 0, 0)
                    glutSolidSphere(6 - i * 2, 6, 6)
                    glPopMatrix()
            elif self.creature_type == MELEE_CREATURE:
                glColor3f(0.8, 0.2, 0.2)
                glutSolidCube(10)
            else:
                glColor3f(0.7, 0.7, 0.4)
                glutSolidSphere(6, 8, 8)
                
            glPopMatrix()

def spawn_new_enemies():
    global active_enemies, bosses
    active_enemies = []
    bosses = []
    
    for i in range(MAX_ENEMIES):
        x = random.randint(-400, 400)
        y = random.randint(-400, 400)
        
        if i < 2:
            active_enemies.append(EnemyCreature(x, y, 30, MELEE_CREATURE))
        elif i < 4:
            active_enemies.append(EnemyCreature(x, y, 30, RANGED_ATTACKER))
        else:
            bosses.append(EnemyCreature(x, y, 50, FINAL_BOSS))

def update_all_enemies(delta_time):
    global player_health
    
    for creature in active_enemies:
        creature.update(delta_time)
        distance = math.sqrt((creature.x - player_x)**2 + (creature.y - player_y)**2)
        if distance < creature.collision_radius + 40:
            player_health = max(0, player_health - 1)
            
    for boss in bosses:
        boss.update(delta_time)
        distance = math.sqrt((boss.x - player_x)**2 + (boss.y - player_y)**2)
        if distance < boss.collision_radius + 40:
            player_health = max(0, player_health - 2)

def render_all_enemies():
    for creature in active_enemies:
        creature.render_creature()
    for boss in bosses:
        boss.render_creature()

def get_all_enemies():
    return active_enemies + bosses

def deal_damage_at_location(x, y, damage_amount, splash_effect_radius=50):
    for creature in active_enemies + bosses:
        if creature.is_dead:
            continue
        distance = math.sqrt((creature.x - x)**2 + (creature.y - y)**2)
        if distance <= splash_effect_radius:
            creature.take_damage(damage_amount)
