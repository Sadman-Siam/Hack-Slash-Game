import math
import random
import time

# Global game state variables
player_x = 500
player_y = 500
player_z = 50
current_time = 0

# Class for regular enemies
class EnemyCreature:
    def __init__(self, x_coord, y_coord):
        self.x, self.y, self.z = x_coord, y_coord, 50
        
        self.current_health = 100
        self.movement_speed = 3.0
        self.is_dead = False

        self.behavior_state = "wandering"
        self.patrol_direction = random.random() * 2 * math.pi
        self.target_position = [0, 0]

        self.equipped_weapon = "gun"
        self.attack_range = {
            "gun": 500,
            "sword": 100
        }
        self.attack_cooldown = {
            "gun": 1.5,
            "sword": 0.8
        }
        self.last_attack_time = 0

    def get_distance_to_player(self):
        dx = self.target_position[0] - self.x
        dy = self.target_position[1] - self.y
        return math.sqrt(dx**2 + dy**2)

    def update_behavior_and_weapons(self, delta_time):
        distance_to_player = self.get_distance_to_player()

        if distance_to_player < self.attack_range["sword"]:
            self.behavior_state = "fighting"
            self.equipped_weapon = "sword"
        elif distance_to_player < self.attack_range["gun"]:
            self.behavior_state = "hunting"
            self.equipped_weapon = "gun"
        else:
            self.behavior_state = "wandering"
            self.equipped_weapon = "gun"

        if self.behavior_state == "hunting" or self.behavior_state == "fighting":
            self.chase_player(delta_time)
            if self.equipped_weapon == "gun" and current_time - self.last_attack_time > self.attack_cooldown["gun"]:
                self.fire_gun()
                self.last_attack_time = current_time
            elif self.equipped_weapon == "sword" and current_time - self.last_attack_time > self.attack_cooldown["sword"]:
                self.perform_sword_swing()
                self.last_attack_time = current_time
        elif self.behavior_state == "wandering":
            self.wander_around(delta_time)

    def chase_player(self, delta_time):
        dx = self.target_position[0] - self.x
        dy = self.target_position[1] - self.y
        distance = math.sqrt(dx**2 + dy**2)

        if distance > 1:
            dir_x = dx / distance
            dir_y = dy / distance

            self.x += dir_x * self.movement_speed * delta_time
            self.y += dir_y * self.movement_speed * delta_time
            
    def wander_around(self, delta_time):
        self.x += math.cos(self.patrol_direction) * self.movement_speed * delta_time * 0.5
        self.y += math.sin(self.patrol_direction) * self.movement_speed * delta_time * 0.5
        if random.random() < 0.01:
            self.patrol_direction = random.random() * 2 * math.pi

    def perform_sword_swing(self):
        print(f"[{time.time():.2f}] Enemy swings sword!")

    def fire_gun(self):
        print(f"[{time.time():.2f}] Enemy fires gun!")

    def take_damage(self, amount):
        self.current_health -= amount
        if self.current_health <= 0:
            self.is_dead = True
            print(f"Enemy has been defeated!")
        else:
            print(f"Enemy takes {amount} damage. Health: {self.current_health}")

    def update(self, delta_time):
        global current_time
        self.target_position = [player_x, player_y]
        
        if not self.is_dead:
            self.update_behavior_and_weapons(delta_time)

---

### Final Boss Class

The `FinalBoss` is a separate entity with its own unique properties, such as higher health and a fixed, powerful attack.

```python
class FinalBoss:
    def __init__(self, x_coord, y_coord):
        self.x, self.y = x_coord, y_coord
        
        self.current_health = 500  # Much higher health
        self.movement_speed = 2.0
        self.is_dead = False

        self.target_position = [0, 0]
        self.attack_cooldown = 2.0
        self.last_attack_time = 0

    def get_distance_to_player(self):
        dx = self.target_position[0] - self.x
        dy = self.target_position[1] - self.y
        return math.sqrt(dx**2 + dy**2)
        
    def chase_player(self, delta_time):
        dx = self.target_position[0] - self.x
        dy = self.target_position[1] - self.y
        distance = math.sqrt(dx**2 + dy**2)

        if distance > 1:
            dir_x = dx / distance
            dir_y = dy / distance
            self.x += dir_x * self.movement_speed * delta_time
            self.y += dir_y * self.movement_speed * delta_time
    
    def fire_laser(self):
        print(f"[{time.time():.2f}] Final Boss fires its laser!")

    def take_damage(self, amount):
        self.current_health -= amount
        if self.current_health <= 0:
            self.is_dead = True
            print(f"Final Boss has been defeated!")
        else:
            print(f"Final Boss takes {amount} damage. Health: {self.current_health}")
            
    def update(self, delta_time):
        global current_time
        self.target_position = [player_x, player_y]

        if not self.is_dead:
            self.chase_player(delta_time)
            if current_time - self.last_attack_time > self.attack_cooldown:
                self.fire_laser()
                self.last_attack_time = current_time

---

### Game Simulation with Boss Encounter

```python
def simulate_game():
    global current_time, player_x, player_y
    
    enemies = [EnemyCreature(x_coord=0, y_coord=0), EnemyCreature(x_coord=200, y_coord=200)]
    boss = None

    last_time = time.time()
    
    print("--- Starting Game Simulation ---")
    print("Defeat all regular enemies to spawn the boss.")
    
    while True:
        current_time = time.time()
        delta_time = current_time - last_time
        last_time = current_time
        
        # Simulate player movement
        player_x -= 10 * delta_time
        player_y -= 10 * delta_time

        # If there are regular enemies, update and manage them
        if enemies:
            print(f"Active enemies: {len(enemies)}")
            for enemy in enemies:
                enemy.update(delta_time)
                # For demonstration, simulate enemy taking a fixed amount of damage each frame
                enemy.take_damage(5) 
            
            enemies_to_keep = [enemy for enemy in enemies if not enemy.is_dead]
            enemies = enemies_to_keep
            
        # If all regular enemies are defeated, spawn the boss
        elif not boss:
            print("\nAll enemies have been defeated! A final boss has appeared!")
            boss = FinalBoss(x_coord=500, y_coord=500)

        # If the boss has spawned, update it
        elif boss:
            print(f"Final Boss Health: {boss.current_health}")
            boss.update(delta_time)
            # Simulate boss taking a fixed amount of damage
            boss.take_damage(20)

        # Check for game end condition (boss is dead)
        if boss and boss.is_dead:
            print("\nCongratulations! You have defeated the Final Boss!")
            print("--- Game Over! ---")
            break
            
        time.sleep(0.1)

if __name__ == "__main__":
    simulate_game()
