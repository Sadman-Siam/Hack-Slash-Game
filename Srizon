from OpenGL.GL import *
from OpenGL.GLUT import *
from OpenGL.GLU import *
import random
import math
import time

# Camera and display settings
camera_pos = (0, 500, 500)
camera_mode = "third_person"
fovY = 120
GRID_LENGTH = 2000

# Day/Night cycle
day_night_cycle = 0  # 0 to 1, where 0 is day, 1 is night

# Character properties
character_pos = [0, 0, 50]
character_size = 30
character_speed = 20

# Player position variables
player_x = 0
player_y = 0 
player_z = 50
movement_speed = 20.0
base_movement_speed = 20.0
max_movement_speed = 50.0

# Player stats
player_health = 100
max_health = 200

# Player rotation and weapon variables
player_rotation = 0
current_weapon = "gun"
bullets = []
bullet_speed = 15.0
bullet_size = 5

# Sword
sword_swing_active = False
sword_swing_timer = 0
sword_swing_angle = 90
sword_swing_speed = 8

# Collectibles system
collectibles = []
collectible_size = 25
max_collectibles = 2
spawn_timer = 0
spawn_interval = 300

# Map obstacles for each level
obstacles = {
    1: [
        {"type": "cube", "x": -400, "y": -400, "z": 50, "size": 100},
        {"type": "cube", "x": 400, "y": 400, "z": 50, "size": 100},
        {"type": "cylinder", "x": -400, "y": 400, "z": 0, "radius": 60, "height": 100},
        {"type": "cylinder", "x": 400, "y": -400, "z": 0, "radius": 60, "height": 100},
    ],
    2: [
        {"type": "cube", "x": 0, "y": 0, "z": 50, "size": 80},
        {"type": "cylinder", "x": -500, "y": -500, "z": 0, "radius": 70, "height": 120},
        {"type": "cylinder", "x": 500, "y": 500, "z": 0, "radius": 70, "height": 120},
    ],
    3: [
        {"type": "cube", "x": 500, "y": 0, "z": 50, "size": 80},
        {"type": "cube", "x": -500, "y": 0, "z": 50, "size": 80},
        {"type": "cube", "x": 0, "y": 500, "z": 50, "size": 80},
        {"type": "cube", "x": 0, "y": -500, "z": 50, "size": 80},
    ]
}

# Level tracking
current_level = 1

# Enemy system variables
last_frame = time.time()
enemy_list = []
boss_list = []
MAX_ENEMIES = 5

MELEE_TYPE = 1
RANGED_TYPE = 2
BOSS_TYPE = 3

# Display lists for optimization
cube_display_list = 0
cylinder_display_list = 0

class Enemy:
    def __init__(self, x, y, z, etype):
        self.x, self.y, self.z = x, y, z
        self.type = etype
        self.hp = 500 if etype == BOSS_TYPE else 100
        self.max_hp = self.hp
        self.move_speed = 1.0 if etype == BOSS_TYPE else (2.0 if etype == MELEE_TYPE else 1.5)
        self.dead = False
        self.anim_t = 0
        self.spawn_x, self.spawn_y = x, y
        self.current_state = "wandering"
        self.radius = 80 if etype == BOSS_TYPE else 40
        
        self.weapon = "sword"
        self.sword_reach = 100 if etype == BOSS_TYPE else 80
        self.gun_reach = 400 if etype == BOSS_TYPE else 300
        self.sword_dmg = 60 if etype == BOSS_TYPE else 30
        self.gun_dmg = 40 if etype == BOSS_TYPE else 20
        self.sword_delay = 0.5 if etype == BOSS_TYPE else 0.8
        self.gun_delay = 1.0 if etype == BOSS_TYPE else 1.5
        self.last_shot = 0
        self.swing_active = False
        self.swing_timer = 0
        
        if etype == BOSS_TYPE:
            self.special_delay = 5.0
            self.last_special = 0
        
        self.bullets = []
        self.patrol_angle = random.random() * 6.28
        self.wander_dist = 100

    def tick(self, dt):
        global player_health
        
        if self.dead:
            return
            
        self.anim_t += dt
        now = time.time()
        
        self.patrol_angle += dt * 0.5
        
        target = [player_x, player_y, player_z]
        dist = self.get_dist(target)
        
        if dist <= self.sword_reach:
            self.weapon = "sword"
        elif dist <= self.gun_reach:
            self.weapon = "gun"
        else:
            self.weapon = "gun"
        
        if self.swing_active:
            self.swing_timer += dt
            if self.swing_timer > 0.5:
                self.swing_active = False
                self.swing_timer = 0
        
        self.do_ai_stuff(dt, dist, now, target)
        self.update_bullets(dt)
        
        self.check_bullet_player_collision()

    def get_dist(self, target):
        dx = self.x - target[0]
        dy = self.y - target[1]
        return math.sqrt(dx*dx + dy*dy)

    def do_ai_stuff(self, dt, dist, now, target):
        if self.type == MELEE_TYPE:
            if dist < 350:
                self.current_state = "hunting"
                if dist > self.sword_reach and self.weapon == "sword":
                    dx = target[0] - self.x
                    dy = target[1] - self.y
                    length = math.sqrt(dx*dx + dy*dy)
                    if length > 0:
                        self.x += (dx/length) * self.move_speed * dt * 60
                        self.y += (dy/length) * self.move_speed * dt * 60
                else:
                    self.current_state = "fighting"
                    delay = self.sword_delay if self.weapon == "sword" else self.gun_delay
                    if now - self.last_shot > delay:
                        self.do_attack(target)
                        self.last_shot = now
            else:
                self.current_state = "wandering"
                self.wander_around(dt)
        
        elif self.type == RANGED_TYPE:
            if dist < 400:
                if dist <= self.sword_reach and self.weapon == "sword":
                    self.current_state = "fighting"
                    if now - self.last_shot > self.sword_delay:
                        self.sword_swing()
                        self.last_shot = now
                elif dist <= self.gun_reach and self.weapon == "gun":
                    self.current_state = "fighting"
                    if now - self.last_shot > self.gun_delay:
                        self.shoot_gun(target)
                        self.last_shot = now
                else:
                    self.current_state = "positioning"
                    good_range = self.gun_reach * 0.7
                    if dist < good_range:
                        dx = self.x - target[0]
                        dy = self.y - target[1]
                        length = math.sqrt(dx*dx + dy*dy)
                        if length > 0:
                            self.x += (dx/length) * self.move_speed * dt * 40
                            self.y += (dy/length) * self.move_speed * dt * 40
                    else:
                        dx = target[0] - self.x
                        dy = target[1] - self.y
                        length = math.sqrt(dx*dx + dy*dy)
                        if length > 0:
                            self.x += (dx/length) * self.move_speed * dt * 40
                            self.y += (dy/length) * self.move_speed * dt * 40
            else:
                self.current_state = "wandering"
                self.wander_around(dt)
        
        elif self.type == BOSS_TYPE:
            if dist < 500:
                if dist > self.sword_reach:
                    self.current_state = "hunting"
                    dx = target[0] - self.x
                    dy = target[1] - self.y
                    length = math.sqrt(dx*dx + dy*dy)
                    if length > 0:
                        self.x += (dx/length) * self.move_speed * dt * 60
                        self.y += (dy/length) * self.move_speed * dt * 60
                
                self.current_state = "fighting"
                delay = self.sword_delay if self.weapon == "sword" else self.gun_delay
                if now - self.last_shot > delay:
                    if self.weapon == "sword":
                        self.sword_swing()
                    else:
                        self.shoot_gun(target)
                    self.last_shot = now
                
                if now - self.last_special > self.special_delay:
                    self.boss_special()
                    self.last_special = now

    def wander_around(self, dt):
        angle = self.patrol_angle
        target_x = self.spawn_x + math.cos(angle) * self.wander_dist
        target_y = self.spawn_y + math.sin(angle) * self.wander_dist
        
        dx = target_x - self.x
        dy = target_y - self.y
        length = math.sqrt(dx*dx + dy*dy)
        if length > 5:
            self.x += (dx/length) * self.move_speed * dt * 30
            self.y += (dy/length) * self.move_speed * dt * 30

    def do_attack(self, target):
        if self.weapon == "sword":
            self.sword_swing()
            if self.get_dist(target) <= self.sword_reach:
                self.damage_player(self.sword_dmg)
        else:
            self.shoot_gun(target)

    def sword_swing(self):
        self.swing_active = True
        self.swing_timer = 0

    def shoot_gun(self, target):
        dx = target[0] - self.x
        dy = target[1] - self.y
        length = math.sqrt(dx*dx + dy*dy)
        if length > 0:
            vel_x = dx/length * 250
            vel_y = dy/length * 250
            bullet = {
                'x': self.x, 'y': self.y, 'z': self.z + 20,
                'vx': vel_x, 'vy': vel_y,
                'life': 4.0, 'dmg': self.gun_dmg,
                'is_special': False
            }
            self.bullets.append(bullet)

    def boss_special(self):
        if self.type == BOSS_TYPE:
            self.swing_active = True
            for i in range(0, 360, 20):
                angle = math.radians(i)
                vel_x = math.cos(angle) * 200
                vel_y = math.sin(angle) * 200
                bullet = {
                    'x': self.x, 'y': self.y, 'z': self.z + 20,
                    'vx': vel_x, 'vy': vel_y,
                    'life': 5.0, 'dmg': self.gun_dmg,
                    'is_special': True
                }
                self.bullets.append(bullet)

    def update_bullets(self, dt):
        for bullet in self.bullets[:]:
            bullet['x'] += bullet['vx'] * dt
            bullet['y'] += bullet['vy'] * dt
            bullet['life'] -= dt
            
            if bullet['life'] <= 0:
                self.bullets.remove(bullet)

    def check_bullet_player_collision(self):
        global player_health
        
        for bullet in self.bullets[:]:
            dx = bullet['x'] - player_x
            dy = bullet['y'] - player_y
            dz = bullet['z'] - player_z
            distance = math.sqrt(dx*dx + dy*dy + dz*dz)
            
            if distance < 50:
                self.damage_player(bullet['dmg'])
                self.bullets.remove(bullet)

    def damage_player(self, damage):
        global player_health
        player_health = max(0, player_health - damage)
        if player_health <= 0:
            print("Game Over! Player defeated!")

    def hurt(self, damage):
        self.hp -= damage
        if self.hp <= 0:
            self.dead = True

    def render(self):
        if self.dead:
            return

        # Enhanced animation with bounce and rotation
        bounce = 5 * math.sin(self.anim_t * 2)
        rotation = 15 * math.sin(self.anim_t)
        
        glPushMatrix()
        glTranslatef(self.x, self.y, self.z + bounce)
        glRotatef(rotation, 0, 0, 1)
        
        # Simple sphere-based enemy design with improved visuals
        if self.type == MELEE_TYPE:
            glPushMatrix()
            glColor3f(1, 0.2, 0.2)  # Brighter red
            glutSolidSphere(25, 30, 30)  # Higher poly count
            glPopMatrix()
            
            glPushMatrix()
            glColor3f(0.1, 0.1, 0.1)
            glTranslatef(0, 0, 30)
            glutSolidSphere(12, 20, 20)
            glPopMatrix()
                
        elif self.type == RANGED_TYPE:
            glPushMatrix()
            glColor3f(0.2, 0.2, 1)  # Brighter blue
            glutSolidSphere(25, 30, 30)
            glPopMatrix()
            
            glPushMatrix()
            glColor3f(0.1, 0.1, 0.1)
            glTranslatef(0, 0, 30)
            glutSolidSphere(12, 20, 20)
            glPopMatrix()
                
        else:  # BOSS_TYPE
            glPushMatrix()
            glColor3f(0.6, 0.2, 0.8)  # Vibrant purple
            glutSolidSphere(35, 40, 40)
            glPopMatrix()
            
            glPushMatrix()
            glColor3f(0.1, 0.1, 0.1)
            glTranslatef(0, 0, 40)
            glutSolidSphere(18, 20, 20)
            glPopMatrix()
        
        self.draw_current_weapon()
        glPopMatrix()
        
        self.draw_hp_bar()
        self.draw_bullets()

    def draw_current_weapon(self):
        if self.weapon == "sword":
            self.draw_sword()
        else:
            self.draw_gun()
    
    def draw_sword(self):
        glPushMatrix()
        glTranslatef(self.radius * 0.7, 0, 0)
        
        if self.swing_active:
            swing = math.sin(self.swing_timer * 10) * 50
            glRotatef(swing, 0, 0, 1)
        
        if self.type == MELEE_TYPE:
            glColor3f(1.0, 0.1, 0.1)
            glPushMatrix()
            glScalef(0.08, 0.9, 0.04)
            glCallList(cube_display_list)
            glPopMatrix()
                
        elif self.type == BOSS_TYPE:
            glColor3f(0.7, 0.6, 0.3)
            glPushMatrix()
            glScalef(0.12, 1.1, 0.06)
            glCallList(cube_display_list)
            glPopMatrix()
        else:
            glColor3f(0.0, 0.9, 1.0)
            glPushMatrix()
            glScalef(0.05, 0.8, 0.03)
            glCallList(cube_display_list)
            glPopMatrix()
        
        glColor3f(0.2, 0.2, 0.25)
        glPushMatrix()
        glTranslatef(0, -40, 0)
        glutSolidCylinder(6, 25, 12, 12)
        glPopMatrix()
        
        glPopMatrix()
    
    def draw_gun(self):
        glPushMatrix()
        glTranslatef(self.radius * 0.6, 0, 10)
        
        dx = player_x - self.x
        dy = player_y - self.y
        if dx != 0 or dy != 0:
            angle = math.degrees(math.atan2(dy, dx))
            glRotatef(angle, 0, 0, 1)
        
        if self.type == RANGED_TYPE:
            glColor3f(0.15, 0.2, 0.25)
            glPushMatrix()
            glTranslatef(25, 0, 0)
            glRotatef(90, 0, 1, 0)
            glutSolidCylinder(6, 50, 12, 12)
            glPopMatrix()
            
            glColor3f(0.0, 0.7, 1.0)
            glPushMatrix()
            glTranslatef(10, 0, 0)
            glutSolidSphere(8, 12, 12)
            glPopMatrix()
            
        elif self.type == BOSS_TYPE:
            glColor3f(0.4, 0.3, 0.2)
            glPushMatrix()
            glTranslatef(35, 0, 0)
            glRotatef(90, 0, 1, 0)
            glutSolidCylinder(10, 80, 16, 16)
            glPopMatrix()
            
            glColor3f(0.9, 0.7, 0.3)
            glPushMatrix()
            glTranslatef(60, 0, 0)
            glutSolidSphere(18, 16, 16)
            glPopMatrix()
        else:
            glColor3f(0.4, 0.4, 0.45)
            glPushMatrix()
            glTranslatef(20, 0, 0)
            glScalef(0.7, 0.12, 0.12)
            glCallList(cube_display_list)
            glPopMatrix()
        
        glPopMatrix()

    def draw_hp_bar(self):
        if self.dead:
            return
            
        glPushMatrix()
        glTranslatef(self.x, self.y, self.z + self.radius + 30)
        
        glColor3f(0.3, 0.3, 0.3)
        glBegin(GL_QUADS)
        glVertex3f(-25, -3, 0)
        glVertex3f(25, -3, 0)
        glVertex3f(25, 3, 0)
        glVertex3f(-25, 3, 0)
        glEnd()
        
        hp_pct = self.hp / self.max_hp
        if hp_pct > 0.6:
            glColor3f(0.0, 1.0, 0.0)
        elif hp_pct > 0.3:
            glColor3f(1.0, 1.0, 0.0)
        else:
            glColor3f(1.0, 0.0, 0.0)
            
        glBegin(GL_QUADS)
        glVertex3f(-25, -2, 1)
        glVertex3f(-25 + 50 * hp_pct, -2, 1)
        glVertex3f(-25 + 50 * hp_pct, 2, 1)
        glVertex3f(-25, 2, 1)
        glEnd()
        
        glPopMatrix()

    def draw_bullets(self):
        for b in self.bullets:
            glPushMatrix()
            glTranslatef(b['x'], b['y'], b['z'])
            
            if b['is_special']:
                glRotatef(time.time() * 120, 0, 1, 0)
                glColor3f(1.0, 0.9, 0.4)
                glCallList(cube_display_list)
                glColor3f(0.9, 0.7, 0.3)
                glutWireCube(20)
            elif self.type == RANGED_TYPE:
                glColor3f(0.3, 0.9, 1.0)
                glutSolidSphere(8, 12, 12)
            elif self.type == MELEE_TYPE:
                glColor3f(0.9, 0.3, 0.3)
                glCallList(cube_display_list)
            else:
                glColor3f(0.8, 0.8, 0.5)
                glutSolidSphere(6, 10, 10)
                
            glPopMatrix()

def init_display_lists():
    global cube_display_list, cylinder_display_list
    cube_display_list = glGenLists(1)
    glNewList(cube_display_list, GL_COMPILE)
    glutSolidCube(80)
    glEndList()
    
    cylinder_display_list = glGenLists(1)
    glNewList(cylinder_display_list, GL_COMPILE)
    gluCylinder(gluNewQuadric(), 60, 60, 100, 20, 20)
    glEndList()

def spawn_enemies():
    global enemy_list, boss_list
    enemy_list = []
    boss_list = []
    
    for i in range(MAX_ENEMIES):
        x = random.randint(-800, 800)
        y = random.randint(-800, 800)
        
        while math.sqrt(x*x + y*y) < 200:
            x = random.randint(-800, 800)
            y = random.randint(-800, 800)
        
        if i < 2:
            enemy_list.append(Enemy(x, y, 30, MELEE_TYPE))
        elif i < 4:
            enemy_list.append(Enemy(x, y, 30, RANGED_TYPE))
        else:
            boss_list.append(Enemy(x, y, 50, BOSS_TYPE))

def tick_all_enemies(dt):
    for e in enemy_list[:]:
        if not e.dead:
            e.tick(dt)
        else:
            enemy_list.remove(e)
    
    for b in boss_list[:]:
        if not b.dead:
            b.tick(dt)
        else:
            boss_list.remove(b)

def render_all_enemies():
    for e in enemy_list:
        e.render()
    for b in boss_list:
        b.render()

def get_enemies():
    return enemy_list + boss_list

def damage_at_pos(x, y, dmg, splash_radius=50):
    for e in enemy_list + boss_list:
        if e.dead:
            continue
        dist = math.sqrt((e.x - x)**2 + (e.y - y)**2)
        if dist <= splash_radius:
            e.hurt(dmg)

def draw_obstacles():
    for obstacle in obstacles[current_level]:
        glPushMatrix()
        glTranslatef(obstacle['x'], obstacle['y'], obstacle['z'])
        
        if obstacle['type'] == 'cube':
            glColor3f(0.9, 0.7, 0.5)
            glCallList(cube_display_list)
        elif obstacle['type'] == 'cylinder':
            glColor3f(0.5, 0.7, 0.9)
            glRotatef(90, 1, 0, 0)
            glCallList(cylinder_display_list)
        
        glPopMatrix()

def check_obstacle_collision(new_x, new_y):
    player_radius = 40
    
    for obstacle in obstacles[current_level]:
        obs_x, obs_y = obstacle['x'], obstacle['y']
        
        if obstacle['type'] == 'cube':
            obs_size = obstacle['size']
            dist = math.sqrt((new_x - obs_x)**2 + (new_y - obs_y)**2)
            if dist < (player_radius + obs_size/2):
                return True
        elif obstacle['type'] == 'cylinder':
            obs_radius = obstacle['radius']
            dist = math.sqrt((new_x - obs_x)**2 + (new_y - obs_y)**2)
            if dist < (player_radius + obs_radius):
                return True
    
    return False

def spawn_collectible():
    global collectibles
    
    if len(collectibles) < max_collectibles:
        x = random.randint(-GRID_LENGTH + 100, GRID_LENGTH - 100)
        y = random.randint(-GRID_LENGTH + 100, GRID_LENGTH - 100)
        z = collectible_size
        cube_type = random.choice(['health', 'speed'])
        rotation = 0
        pulse_timer = 0
        collectibles.append([x, y, z, cube_type, rotation, pulse_timer])

def draw_collectible(x, y, z, cube_type, rotation, pulse_timer):
    glPushMatrix()
    glTranslatef(x, y, z)
    glRotatef(rotation, 0, 0, 1)
    
    # Pulsating effect
    pulse_scale = 1.0 + 0.1 * math.sin(pulse_timer * 2)
    glScalef(pulse_scale, pulse_scale, pulse_scale)
    
    if cube_type == 'health':
        glColor3f(0.2, 1.0, 0.2)
    elif cube_type == 'speed':
        glColor3f(1.0, 0.2, 0.2)
    
    glCallList(cube_display_list)
    glPopMatrix()

def draw_all_collectibles():
    for collectible in collectibles:
        x, y, z, cube_type, rotation, pulse_timer = collectible
        draw_collectible(x, y, z, cube_type, rotation, pulse_timer)

def update_collectibles():
    global collectibles, spawn_timer
    
    for collectible in collectibles:
        collectible[4] = (collectible[4] + 2) % 360
        collectible[5] = (collectible[5] + 0.1) % (2 * math.pi)
    
    spawn_timer += 1
    if spawn_timer >= spawn_interval:
        spawn_collectible()
        spawn_timer = 0

def check_collectible_collision():
    global collectibles, player_health, movement_speed
    
    player_collision_radius = 60
    
    for i, collectible in enumerate(collectibles):
        x, y, z, cube_type, rotation, _ = collectible
        
        dx = player_x - x
        dy = player_y - y
        distance = math.sqrt(dx*dx + dy*dy)
        
        if distance < (player_collision_radius + collectible_size/2):
            if cube_type == 'health':
                health_gain = 25
                player_health = min(player_health + health_gain, max_health)
                print(f"Health collected! +{health_gain} HP (Current: {player_health})")
                
            elif cube_type == 'speed':
                speed_boost = 5.0
                movement_speed = min(movement_speed + speed_boost, max_movement_speed)
                print(f"Speed boost collected! +{speed_boost} speed (Current: {movement_speed:.1f})")
            
            collectibles.pop(i)
            break

def draw_text(x, y, text):
    glColor3f(1, 1, 1)
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    
    gluOrtho2D(0, 1000, 0, 800)
    
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    
    glRasterPos2f(x, y)
    for ch in text:
        try:
            glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, ord(ch))
        except:
            pass
    
    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)

def draw_player_health_bar():
    glMatrixMode(GL_PROJECTION)
    glPushMatrix()
    glLoadIdentity()
    gluOrtho2D(0, 1000, 0, 800)
    
    glMatrixMode(GL_MODELVIEW)
    glPushMatrix()
    glLoadIdentity()
    
    glColor3f(0.3, 0.3, 0.3)
    glBegin(GL_QUADS)
    glVertex2f(50, 750)
    glVertex2f(250, 750)
    glVertex2f(250, 770)
    glVertex2f(50, 770)
    glEnd()
    
    hp_pct = player_health / max_health
    if hp_pct > 0.6:
        glColor3f(0.0, 1.0, 0.0)
    elif hp_pct > 0.3:
        glColor3f(1.0, 1.0, 0.0)
    else:
        glColor3f(1.0, 0.0, 0.0)
    
    glBegin(GL_QUADS)
    glVertex2f(50, 751)
    glVertex2f(50 + 200 * hp_pct, 751)
    glVertex2f(50 + 200 * hp_pct, 769)
    glVertex2f(50, 769)
    glEnd()
    
    glPopMatrix()
    glMatrixMode(GL_PROJECTION)
    glPopMatrix()
    glMatrixMode(GL_MODELVIEW)

def draw_player():
    glPushMatrix()
    
    glTranslatef(player_x, player_y, player_z)
    glRotatef(player_rotation, 0, 0, 1)
    
    glColor3f(0.6, 1.0, 0.6)
    glCallList(cube_display_list)
    
    glTranslatef(0, 0, 80)
    glColor3f(0.1, 0.1, 0.1)
    gluSphere(gluNewQuadric(), 30, 15, 15)
    
    glColor3f(1, 0.9, 0.8)
    glTranslatef(50, -30, -70)
    glRotatef(90, 1, 0, 0)
    gluCylinder(gluNewQuadric(), 30, 15, 100, 12, 12)
    glTranslatef(-100, 0, 0)
    gluCylinder(gluNewQuadric(), 30, 15, 100, 12, 12)
    
    glColor3f(0.1, 0.1, 0.8)
    glRotatef(90, 1, 0, 0)
    glTranslatef(0, 10, 100)
    gluCylinder(gluNewQuadric(), 30, 15, 100, 12, 12)
    glTranslatef(100, 0, 0)
    gluCylinder(gluNewQuadric(), 30, 15, 100, 12, 12)
    
    glColor3f(0.6, 0.6, 0.6)
    glRotatef(-90, 1, 0, 0)
    
    if current_weapon == "gun":
        glTranslatef(-110, 70, 80)
        gluCylinder(gluNewQuadric(), 30, 15, 100, 12, 12)
    elif current_weapon == "sword":
        current_angle = sword_swing_angle if sword_swing_active else 90
        draw_sword(current_angle, 0, 1, 0)
    
    glPopMatrix()

def draw_sword(sword_angle=90, x=0, y=1, z=0):
    glPushMatrix()
    
    glColor3f(1, 0.1, 0.1)
    glTranslatef(-100, 100, 90)
    glRotatef(sword_angle, x, y, z)
    gluCylinder(gluNewQuadric(), 20, 1, 250, 25, 25)
    
    glColor3f(0.5, 0.3, 0.2)
    glTranslatef(0, 0, -30)
    gluCylinder(gluNewQuadric(), 25, 25, 30, 12, 12)
    
    glPopMatrix()

def draw_bullet(x, y, z):
    glPushMatrix()
    glColor3f(1, 0.2, 0.2)
    glTranslatef(x, y, z)
    glutSolidSphere(bullet_size, 10, 10)
    glPopMatrix()

def draw_all_bullets():
    for bullet in bullets:
        draw_bullet(bullet[0], bullet[1], bullet[2])

def update_bullets():
    global bullets

    for i, bullet in enumerate(bullets):
        bullet[0] += bullet[3]
        bullet[1] += bullet[4]
        bullet[2] += bullet[5]
        
        for enemy in get_enemies():
            if not enemy.dead:
                dx = bullet[0] - enemy.x
                dy = bullet[1] - enemy.y
                dz = bullet[2] - enemy.z
                distance = math.sqrt(dx*dx + dy*dy + dz*dz)
                
                if distance < 50:
                    enemy.hurt(50)
                    bullets.pop(i)
                    break
        
        if abs(bullet[0]) > 2000 or abs(bullet[1]) > 2000:
            bullets.pop(i)

def update_sword_swing():
    global sword_swing_active, sword_swing_timer, sword_swing_angle
    
    if sword_swing_active:
        sword_swing_timer += 1
        swing_duration = 30
        
        if sword_swing_timer <= swing_duration:
            progress = sword_swing_timer / swing_duration
            if progress <= 0.5:
                sword_swing_angle = 90 - (135 * (progress * 2))
            else:
                sword_swing_angle = -45 + (135 * ((progress - 0.5) * 2))
                
            if 10 <= sword_swing_timer <= 20:
                for enemy in get_enemies():
                    if not enemy.dead:
                        dx = player_x - enemy.x
                        dy = player_y - enemy.y
                        distance = math.sqrt(dx*dx + dy*dy)
                        
                        if distance < 120:
                            enemy.hurt(75)
        else:
            sword_swing_active = False
            sword_swing_timer = 0
            sword_swing_angle = 90

def shoot_bullet():
    global bullets
    
    angle_rad = math.radians(player_rotation)
    gun_offset_x = 50 * math.sin(angle_rad)
    gun_offset_y = -30 * math.cos(angle_rad)
    
    gun_x = player_x + gun_offset_x
    gun_y = player_y + gun_offset_y
    gun_z = player_z + 40
    
    bullet_dx = bullet_speed * math.sin(angle_rad)
    bullet_dy = -bullet_speed * math.cos(angle_rad)
    bullet_dz = 0
    
    bullets.append([gun_x, gun_y, gun_z, bullet_dx, bullet_dy, bullet_dz])

def mouseListener(button, state, x, y):
    global sword_swing_active, sword_swing_timer, sword_swing_angle
    
    if button == GLUT_LEFT_BUTTON and state == GLUT_DOWN:
        if current_weapon == "gun":
            shoot_bullet()
        elif current_weapon == "sword":
            for enemy in get_enemies():
                if not enemy.dead:
                    dx = player_x - enemy.x
                    dy = player_y - enemy.y
                    distance = math.sqrt(dx*dx + dy*dy)
                    
                    if distance < 100:
                        enemy.hurt(60)
    
    elif button == GLUT_RIGHT_BUTTON and state == GLUT_DOWN:
        if current_weapon == "sword":
            sword_swing_active = True
            sword_swing_timer = 0
            sword_swing_angle = 90

    glutPostRedisplay()

def setupCamera():
    glMatrixMode(GL_PROJECTION)
    glLoadIdentity()
    gluPerspective(fovY, 1.25, 0.1, 5000)
    glMatrixMode(GL_MODELVIEW)
    glLoadIdentity()

    camera_distance = 300
    camera_height = 150
    angle_rad = math.radians(player_rotation)
    cam_x = player_x - camera_distance * math.cos(angle_rad)
    cam_y = player_y - camera_distance * math.sin(angle_rad)
    cam_z = player_z + camera_height
    
    gluLookAt(cam_x, cam_y, cam_z,
              player_x, player_y, player_z + 50,
              0, 0, 1)

def keyboardListener(key, x, y):
    global character_pos, player_x, player_y, player_z, player_rotation, current_weapon
    
    if key == b'w' or key == b'W':
        angle_rad = math.radians(player_rotation)
        new_x = player_x + movement_speed * math.sin(angle_rad)
        new_y = player_y - movement_speed * math.cos(angle_rad)
        
        if not check_obstacle_collision(new_x, new_y) and -GRID_LENGTH + 100 < new_x < GRID_LENGTH - 100:
            player_x = new_x
            character_pos[0] = new_x
        if not check_obstacle_collision(new_x, new_y) and -GRID_LENGTH + 100 < new_y < GRID_LENGTH - 100:
            player_y = new_y
            character_pos[1] = new_y
            
    elif key == b's' or key == b'S':
        angle_rad = math.radians(player_rotation)
        new_x = player_x - movement_speed * math.sin(angle_rad)
        new_y = player_y + movement_speed * math.cos(angle_rad)
        
        if not check_obstacle_collision(new_x, new_y) and -GRID_LENGTH + 100 < new_x < GRID_LENGTH - 100:
            player_x = new_x
            character_pos[0] = new_x
        if not check_obstacle_collision(new_x, new_y) and -GRID_LENGTH + 100 < new_y < GRID_LENGTH - 100:
            player_y = new_y
            character_pos[1] = new_y
            
    elif key == b'a' or key == b'A':
        angle_rad = math.radians(player_rotation)
        new_x = player_x + movement_speed * math.cos(angle_rad)
        new_y = player_y + movement_speed * math.sin(angle_rad)
        
        if not check_obstacle_collision(new_x, new_y) and -GRID_LENGTH + 100 < new_x < GRID_LENGTH - 100:
            player_x = new_x
            character_pos[0] = new_x
        if not check_obstacle_collision(new_x, new_y) and -GRID_LENGTH + 100 < new_y < GRID_LENGTH - 100:
            player_y = new_y
            character_pos[1] = new_y
            
    elif key == b'd' or key == b'D':
        angle_rad = math.radians(player_rotation)
        new_x = player_x - movement_speed * math.cos(angle_rad)
        new_y = player_y - movement_speed * math.sin(angle_rad)
        
        if not check_obstacle_collision(new_x, new_y) and -GRID_LENGTH + 100 < new_x < GRID_LENGTH - 100:
            player_x = new_x
            character_pos[0] = new_x
        if not check_obstacle_collision(new_x, new_y) and -GRID_LENGTH + 100 < new_y < GRID_LENGTH - 100:
            player_y = new_y
            character_pos[1] = new_y
            
    elif key == b'q' or key == b'Q':
        if current_weapon == "gun":
            current_weapon = "sword"
        else:
            current_weapon = "gun"
    
    elif key == b'r' or key == b'R':
        spawn_enemies()
    
    glutPostRedisplay()

def specialKeyListener(key, x, y):
    global player_rotation
    
    if key == GLUT_KEY_LEFT:
        player_rotation += 10
    elif key == GLUT_KEY_RIGHT:
        player_rotation -= 10
    
    player_rotation = player_rotation % 360
    glutPostRedisplay()

def idle():
    global day_night_cycle, last_frame
    
    current_time = time.time()
    dt = current_time - last_frame
    last_frame = current_time
    
    day_night_cycle = (day_night_cycle + 0.0005) % 1.0
    update_bullets()
    update_sword_swing()
    update_collectibles()
    check_collectible_collision()
    tick_all_enemies(dt)
    
    if player_health <= 0:
        print("Game Over! Press R to respawn enemies and continue...")
    
    if not get_enemies():
        print("All enemies defeated! Spawning new wave...")
        spawn_enemies()
    
    glutPostRedisplay()

def setup_lighting():
    glEnable(GL_LIGHTING)
    glEnable(GL_LIGHT0)
    
    # Day/night affected lighting
    light_intensity = 0.5 + 0.3 * math.sin(day_night_cycle * 2 * math.pi)
    glLightfv(GL_LIGHT0, GL_POSITION, [0, 0, 1000, 0])
    glLightfv(GL_LIGHT0, GL_DIFFUSE, [light_intensity, light_intensity, light_intensity, 1.0])
    glLightfv(GL_LIGHT0, GL_SPECULAR, [0.5, 0.5, 0.5, 1.0])
    
    glEnable(GL_COLOR_MATERIAL)
    glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE)
    glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, [0.5, 0.5, 0.5, 1.0])
    glMaterialf(GL_FRONT_AND_BACK, GL_SHININESS, 50.0)

def showScreen():
    day_color = 0.5 + 0.3 * math.sin(day_night_cycle * 2 * math.pi)
    glClearColor(day_color * 0.2, day_color * 0.2, day_color * 0.4, 1.0)
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT)
    glLoadIdentity()
    glViewport(0, 0, 1000, 800)

    setupCamera()
    setup_lighting()

    # Draw grid with texture-like pattern
    glBegin(GL_QUADS)
    for i in range(-GRID_LENGTH, GRID_LENGTH, 100):
        for j in range(-GRID_LENGTH, GRID_LENGTH, 100):
            color = 0.7 if (i//100 + j//100) % 2 == 0 else 0.9
            glColor3f(color, color * 0.8, color * 0.95)
            glVertex3f(i, j, 0)
            glVertex3f(i + 100, j, 0)
            glVertex3f(i + 100, j + 100, 0)
            glVertex3f(i, j + 100, 0)
    glEnd()

    draw_obstacles()
    draw_player()
    draw_all_bullets()
    draw_all_collectibles()
    render_all_enemies()

    enemies_alive = len([e for e in get_enemies() if not e.dead])
    
    draw_player_health_bar()
    
    draw_text(600, 660, f"Position: ({character_pos[0]:.0f}, {character_pos[1]:.0f})")
    draw_text(600, 640, f"Rotation: {player_rotation:.0f}°")
    draw_text(600, 620, f"Weapon: {current_weapon.upper()}")
    draw_text(600, 600, f"Health: {player_health}/{max_health}")
    draw_text(600, 580, f"Speed: {movement_speed:.1f}")
    draw_text(600, 560, f"Enemies Alive: {enemies_alive}")
    draw_text(600, 540, f"Collectibles: {len(collectibles)}")
    
    draw_text(600, 500, f"Controls:")
    draw_text(600, 480, f"WASD - Move")
    draw_text(600, 460, f"Arrow Keys - Rotate")
    draw_text(600, 440, f"Q - Switch Weapon")
    draw_text(600, 420, f"Left Click - Attack")
    draw_text(600, 400, f"Right Click - Sword Swing")
    draw_text(600, 380, f"R - Respawn Enemies")

    draw_text(50, 120, f"Collectibles:")
    draw_text(50, 100, f"Green Cube = +25 Health")
    draw_text(50, 80, f"Red Cube = +5 Speed")
    
    draw_text(50, 200, f"Enemies:")
    draw_text(50, 180, f"Red = Melee Fighter")
    draw_text(50, 160, f"Blue = Ranged Fighter") 
    draw_text(50, 140, f"Purple = Boss")

    if player_health <= 0:
        draw_text(400, 400, f"GAME OVER!")
        draw_text(350, 380, f"Press R to continue...")

    glutSwapBuffers()

def main():
    global last_frame
    
    glutInit()
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB | GLUT_DEPTH)
    glutInitWindowSize(1000, 800)
    glutInitWindowPosition(0, 0)
    wind = glutCreateWindow(b"Enhanced 3D Game")

    glEnable(GL_DEPTH_TEST)
    glEnable(GL_NORMALIZE)
    
    init_display_lists()
    
    last_frame = time.time()
    spawn_enemies()
    
    for _ in range(3):
        spawn_collectible()

    glutDisplayFunc(showScreen)
    glutKeyboardFunc(keyboardListener)
    glutSpecialFunc(specialKeyListener)
    glutMouseFunc(mouseListener)
    glutIdleFunc(idle)

    print("Game Started!")
    print("Controls:")
    print("WASD - Move player")
    print("Arrow Keys - Rotate player")
    print("Q - Switch between gun and sword")
    print("Left Click - Attack (shoot/slash)")
    print("Right Click - Sword swing attack")
    print("R - Respawn enemies")
    print("")
    print("Collect green cubes for health, red cubes for speed!")
    print("Defeat all enemies to spawn a new wave!")

    glutMainLoop()

if __name__ == "__main__":
    main()
